# Анализ производительности: Codec vs Libsodium

## Проблема
- **Libsodium**: 38 Мбит/с
- **Codec**: 0.38 Мбит/с
- **Разница**: ~100x медленнее

## Основные узкие места

### 1. Коэффициент расширения данных (5-6x)

**Libsodium:**
- Чанк: 1400 байт
- После шифрования: 1400 + 16 (nonce) + 16 (tag) = ~1432 байт
- Коэффициент: ~1.02x

**Codec:**
- Чанк: 1400 байт
- После сериализации: ~1420 байт (с ChunkHeader)
- После `packBytesToSymbols`: если bitsQ=6, то 8 бит → 6 бит
  - 1420 * 8 / 6 = ~1893 символа
- После `encodeSymbols`: каждый символ → 2 блока [h, v]
  - Если bitsM=16, то bytesPerSymbol() = 2 байта
  - 1893 символа * 2 блока * 2 байта = **7572 байт**
- Коэффициент: **~5.4x**

**Вывод:** Кодек передает в 5-6 раз больше данных по сети!

### 2. Медленное кодирование (encodeSymbols)

Для каждого символа:
1. Вызывается `allCodeFun(x, y)` → вычисляет 2^Q функций (64 для Q=6)
2. Вызывается `allCodeFun(h, v)` → еще 64 функции
3. Итого: **128 вызовов `digitalCodingFun` на символ**

Для чанка (1893 символа):
- **242,304 вызовов `digitalCodingFun`** только на кодирование!

### 3. Очень медленное декодирование (decodeSymbols)

Для каждого символа вызывается `decode11ext` с проверкой 3 гипотез:

**Гипотеза 0 (нет ошибки):**
- `allCodeFun(h1, h2)` → 64 функции
- `allCodeFun(h, h1)` → 64 функции
- Поиск в массивах, пересечения

**Гипотеза 1 (ошибка в h):**
- Перебор Q битов (6 битов для Q=6)
- Для каждого бита:
  - `allCodeFun(h1, h2)` → 64 функции
  - `allCodeFun(tmp, h1)` → 64 функции
  - Поиск в массивах, пересечения
- Итого: **6 * 128 = 768 вызовов** в худшем случае

**Гипотеза 2 (ошибка в v):**
- Аналогично гипотезе 1: **6 * 128 = 768 вызовов**

**Итого для одного символа:**
- В лучшем случае (нет ошибки): 128 вызовов
- В худшем случае: 128 + 768 + 768 = **1664 вызова `digitalCodingFun`**

**Для чанка (1893 символа):**
- В лучшем случае: 242,304 вызовов
- В худшем случае: **3,149,952 вызова** (!!)

### 4. Stop-and-Wait протокол

**Libsodium:**
- Отправка чанка → ожидание ACK → следующий чанк
- При задержке сети 1 мс: пропускная способность ограничена размером чанка / (RTT + время обработки)

**Codec:**
- Та же проблема, но усугубляется:
  - Больше данных для передачи (5-6x)
  - Больше времени на кодирование/декодирование
  - Больше времени на обработку ACK

### 5. Дополнительные накладные расходы

**Codec:**
- Обработка запросов синхронизации (SyncRequest)
- Проверка гипотез при декодировании (даже когда ошибок нет)
- Множественные вызовы `allCodeFun` для каждого символа

**Libsodium:**
- Простое шифрование/дешифрование (оптимизированные ассемблерные функции)
- Минимальные накладные расходы

## Рекомендации по оптимизации

### Краткосрочные (быстрые улучшения):

1. **Увеличить размер чанков**
   - Текущий: 1400 байт
   - Рекомендуемый: 8192-16384 байт
   - Уменьшит количество ACK и накладные расходы

2. **Оптимизировать `allCodeFun`**
   - Кэшировать результаты для часто используемых (x, y)
   - Использовать lookup table для малых Q

3. **Упростить декодирование без ошибок**
   - Если гипотеза 0 успешна, не проверять гипотезы 1 и 2
   - Уже реализовано, но можно оптимизировать дальше

4. **Уменьшить bitsQ и bitsM**
   - Меньше Q → меньше функций в `allCodeFun`
   - Меньше M → меньше байт на блок
   - Но это может ухудшить помехоустойчивость

### Среднесрочные:

5. **Реализовать sliding window протокол**
   - Отправка нескольких чанков без ожидания ACK
   - Увеличит пропускную способность в N раз (где N = размер окна)

6. **Параллельное кодирование/декодирование**
   - Использовать несколько потоков для обработки чанков
   - Особенно эффективно для декодирования

7. **Batch processing**
   - Обрабатывать несколько символов за раз
   - Уменьшить количество вызовов функций

### Долгосрочные:

8. **Переписать `allCodeFun` на GPU**
   - Массово-параллельная обработка
   - Особенно эффективно для больших Q

9. **Использовать более эффективные алгоритмы**
   - Исследовать альтернативные схемы кодирования
   - Уменьшить вычислительную сложность

10. **Гибридный подход**
    - Использовать кодек только для критических данных
    - Libsodium для остальных данных

## Ожидаемые улучшения

| Оптимизация | Ожидаемое улучшение | Сложность |
|------------|---------------------|-----------|
| Увеличение размера чанков | 1.5-2x | Низкая |
| Оптимизация allCodeFun | 2-3x | Средняя |
| Sliding window (окно 10) | 5-10x | Высокая |
| Параллельное декодирование | 2-4x | Высокая |
| **Комбинация всех** | **20-50x** | Очень высокая |

## Выводы

Основные причины низкой скорости:
1. **Коэффициент расширения 5-6x** (больше данных)
2. **Медленное декодирование** (миллионы вызовов функций)
3. **Stop-and-wait протокол** (неэффективное использование сети)

Для достижения скорости >10 Мбит/с необходимо:
- Увеличить размер чанков
- Реализовать sliding window
- Оптимизировать декодирование

