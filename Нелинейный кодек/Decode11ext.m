function [I, pos] = Decode11ext(h1, h2, h, v, COEFF, FunType, flag)
%% РАСШИРЕННОЕ декодирование нелинейного кода типа «1-1»
%  В отличие от Decode11, Decode11ext выдаёт на выход значение pos,
%  указывающее номер бита, в котором произошла ошибка. 
%  Значение тесно связано с аргументом flag:
%  1) Если flag = 0, то pos не играет роли, поскольку в данном случае
%     декодер проверяет лишь наличие/отсутсвие в блоке [h, v] ошибки;
%     если её нет, то I равно декодированному значению в отсутствие ошибок;
%     если I – пустое множество, то ошибка есть в одном из субблоков
%     h или v, и необходима проверка гипотез.
%  2) Если flag = 1 и I – непустое множество, то pos указывает на ошибку в h.
%  3) Если flag = 2 и I – непустое множество, то pos указывает на ошибку в v.
% 
% h1 — значение, отстоящее от текущего на 1 такт в прошлое;
%      технически это значение v(k - 1); тип: fi
% h2 — значение, отстоящее от текущего на 2 такта в прошлое;
%      технически это значение h(k - 1); тип: fi
% h — текущее декодируемое значение; тип: fi
% v — текущее проверочное значение; тип: fi
%     [h v] — декодируемый блок, в котором может быть ошибка;
% COEFF — матрица коэффициентов НПФ;
%         тип: двумерная матрица типа float
% FunType — вид функции, тип: int
% flag — флаг, определяющий алгоритм работы декодера: 1, 2, ...

pos = [];
Q = log2(length(COEFF));


%% Проверка гипотезы об ОТСУТСТВИИ ошибки в обоих блоках пары [h_k, v_k]
if flag == 0
    RR = AllCodeFun([h1 h2], COEFF, FunType);
    RRv = AllCodeFun([h h1], COEFF, FunType);
    indh = find(RR == h);
    indv = find(RRv == v);
    % При специальном подборе НПФ I единственно и уникально.
    % В сложных случаях это может быть вектор из двух и более величин.
    I = intersect(indh, indv);
end



%% Декодирование для случая поражения h_k из пары [h_k, v_k]
if flag == 1
    % Образ ошибок; 3 строки, Q столбцов:
    % 1 — все значения h после инверсии бит с номерами от 1 до Q;
    %     предполагается, что значение h искажено в одной позиции;
    % 2 — индексы совпадений (1) в отклике RR = F(h1, h2);
    %     предполагается, что h1 и h2 уже исправлены или приняты верно;
    % 3 — индексы совпадений (1) в отклике RRv = F(h, h1).
    DecIm = cell(3, Q);
    RR = AllCodeFun([h1 h2], COEFF, FunType);
    for k = 1:Q
        % формирование гипотез о реальном состоянии декодируемого отсчёта;
        % инверсия бит на позициях от 1 до Q
        tmp = BitChange(h, k);  % <—— гипотеза о корректном состоянии h
        DecIm{1, k} = data(tmp);
        % Поиск индексов совпадений tmp в вычисленном эталонном векторе RR
        DecIm{2, k} = find(RR == tmp);
        % Совпадение состояний v, оно не искажено:
        RRv = AllCodeFun([tmp, h1], COEFF, FunType);
        DecIm{3, k} = find(RRv == v);
    end
    I = [];
    % Выбор наиболее вероятной гипотезы о tmp = DecIm{1, k} ——> I
    for k = 1:Q
        % Индексы, полученные по h и индексы, полученные по v,
        % должны иметь хотя бы одно общее значение:
        if isempty(DecIm{2, k}) || isempty(DecIm{3, k}), continue, end
        I = intersect(DecIm{2, k}, DecIm{3, k});
        if ~isempty(I)
            pos = k;
            break
        end
    end
    % Может наблюдаться пересечение/совпадение двух и более индексов;
    % выбираем первый. Для исключения ситуации требуется подбор НПФ.
    % Если I — пустое множество, то делаем вывод,
    % что неверно определено местоположение ошибки в субблоке;
    % flag выбран неверно, гипотеза ошибочна,
    % необходимо проверить следующую гипотезу.
    
    % if length(I) > 1, I = I(1); end
    % Решено убрать для большего контроля снаружи функции.
    % То есть может выдаваться множественный результат
end




%% Декодирование для случая поражения v_k из пары [h_k, v_k]
% В данном случае логика проверки гипотез существенно упрощается:
% по h либо точно, либо приблизительно – в случае наличия коллизий –
% определяются возможные индексы функций, то есть инф. состояние I.
% Затем I либо точно подтверждается,
% либо уточняется по предполагаемому значению v.
if flag == 2
    RR = AllCodeFun([h1 h2], COEFF, FunType);
    indh = find(RR == h);  % <—— индексы по h; точно, не искажено
    RRv = AllCodeFun([h h1], COEFF, FunType);
    DecIm = cell(1, Q);
    for k = 1:Q
        tmp = BitChange(v, k); % гипотеза об истинном состоянии v2
        DecIm{1, k} = find(RRv == tmp);
    end
    % Выбор наиболее вероятной гипотезы о v ——> подтверждение/уточнение I
    I = [];
    for k = 1:Q
        if isempty(DecIm{1, k}), continue, end
        I = intersect(DecIm{1, k}, indh);
        if ~isempty(I)
            pos = k;
            break
        end
    end
    % Бывают неудачные варианты НПФ, когда пересекаются/совпадают
    % два и более индексов; выбираем первый.
    % Если I — пустое множество, то делаем вывод,
    % что неверно определено местоположение ошибки в субблоке;
    % flag выбран неверно. Скорее всего, ошибка в субблоке H.

    % if length(I) > 1, I = I(1); end
    % Решено убрать для большего контроля снаружи функции.
    % То есть может выдаваться множественный результат
end
